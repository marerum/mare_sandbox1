-- Supabase Storage設定SQL
-- SQL Editor で実行してください

-- 1. character-imagesバケットを作成（ダッシュボードで作成済みの場合はスキップ）
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
    'character-images',
    'character-images', 
    true,
    52428800, -- 50MB
    '{"image/jpeg","image/png","image/gif","image/webp"}'
)
ON CONFLICT (id) DO NOTHING;  -- 既に存在する場合はスキップ

-- 2. 管理者管理用テーブルを最初に作成（ポリシーで参照するため）
CREATE TABLE IF NOT EXISTS admin_users (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID REFERENCES users(user_id),
    email TEXT NOT NULL UNIQUE,
    role TEXT DEFAULT 'admin', -- 'admin', 'super_admin', 'moderator' など
    granted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    granted_by UUID, -- 誰が管理者権限を付与したか
    is_active BOOLEAN DEFAULT TRUE
);

-- 管理者テーブルのRLS設定
ALTER TABLE admin_users ENABLE ROW LEVEL SECURITY;

-- 初期管理者データを挿入（開発用 - あなたのメールアドレスに変更してください）
INSERT INTO admin_users (email, role, is_active) VALUES 
('your-main-email@gmail.com', 'super_admin', true),
('backup-admin@gmail.com', 'admin', true)
ON CONFLICT (email) DO NOTHING;  -- 既に存在する場合はスキップ

-- 3. RLSポリシー設定

-- 認証済みユーザーは画像アップロード可能
CREATE POLICY "Authenticated users can upload character images" ON storage.objects
FOR INSERT WITH CHECK (
    bucket_id = 'character-images' AND 
    auth.role() = 'authenticated'
);

-- ユーザーは自分の画像のみ読取可能（プライベート図鑑方式）
CREATE POLICY "Users can view own character images" ON storage.objects
FOR SELECT USING (
    bucket_id = 'character-images' AND 
    auth.uid()::text = (storage.foldername(name))[1]
);

-- 管理者は全ての画像を読取可能（管理者テーブルベース）
CREATE POLICY "Admin can view all character images" ON storage.objects
FOR SELECT USING (
    bucket_id = 'character-images' AND 
    EXISTS (
        SELECT 1 FROM admin_users au
        JOIN auth.users u ON au.email = u.email
        WHERE u.id = auth.uid() 
        AND au.is_active = true
        AND au.role IN ('admin', 'super_admin')
    )
);

-- ユーザーは自分がアップロードした画像のみ更新可能
CREATE POLICY "Users can update own character images" ON storage.objects
FOR UPDATE USING (
    bucket_id = 'character-images' AND 
    auth.uid()::text = (storage.foldername(name))[1]
);

-- ユーザーは自分がアップロードした画像のみ削除可能
CREATE POLICY "Users can delete own character images" ON storage.objects
FOR DELETE USING (
    bucket_id = 'character-images' AND 
    auth.uid()::text = (storage.foldername(name))[1]
);

-- 4. 確認クエリ
SELECT * FROM storage.buckets WHERE name = 'character-images';

-- 5. user_operationsテーブルにも同様のプライバシーポリシーを追加

-- ユーザーは自分の操作ログ（キャラクター）のみ閲覧可能
CREATE POLICY "Users can view own operations" ON user_operations
FOR SELECT USING (auth.uid()::text = user_id::text);

-- 管理者は全ての操作ログを閲覧可能（管理者テーブルベース）
CREATE POLICY "Admin can view all operations" ON user_operations
FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM admin_users au
        JOIN auth.users u ON au.email = u.email
        WHERE u.id = auth.uid() 
        AND au.is_active = true
        AND au.role IN ('admin', 'super_admin')
    )
);

-- 6. 管理者テーブル追加設定

-- スーパー管理者のみが管理者テーブルを操作可能
CREATE POLICY "Super admin can manage admin users" ON admin_users
FOR ALL USING (
    EXISTS (
        SELECT 1 FROM auth.users 
        WHERE auth.users.id = auth.uid() 
        AND auth.users.email IN (
            'superadmin@yourdomain.com'  -- スーパー管理者のメール
        )
    )
);



-- 管理者権限の階層設定
-- super_admin: 全権限（管理者の追加/削除も可能）
-- admin: 通常の管理権限（データ閲覧・操作）
-- moderator: 限定的な管理権限（読み取りのみなど）

-- モデレーター用のポリシー（読み取りのみ）
CREATE POLICY "Moderator can view all operations" ON user_operations
FOR SELECT USING (
    EXISTS (
        SELECT 1 FROM admin_users au
        JOIN auth.users u ON au.email = u.email
        WHERE u.id = auth.uid() 
        AND au.is_active = true
        AND au.role IN ('moderator', 'admin', 'super_admin')
    )
);

-- 6. ポケモン図鑑風の追加機能用テーブル（オプション）
-- キャラクター発見状況を管理
CREATE TABLE IF NOT EXISTS character_discoveries (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID REFERENCES users(user_id),
    character_name TEXT NOT NULL,
    first_discovered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    discovery_count INTEGER DEFAULT 1,
    is_favorite BOOLEAN DEFAULT FALSE,
    UNIQUE(user_id, character_name)
);

-- キャラクター発見テーブルのRLS設定
ALTER TABLE character_discoveries ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own discoveries" ON character_discoveries
FOR ALL USING (auth.uid()::text = user_id::text);

-- 7. 管理者管理用のヘルパー関数

-- 現在のユーザーが管理者かどうかを確認する関数
CREATE OR REPLACE FUNCTION is_admin(user_email text, required_role text DEFAULT 'admin')
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM admin_users 
        WHERE email = user_email 
        AND is_active = true
        AND (
            role = required_role 
            OR role = 'super_admin'  -- super_adminは常に全権限
            OR (required_role = 'admin' AND role IN ('admin', 'super_admin'))
            OR (required_role = 'moderator' AND role IN ('moderator', 'admin', 'super_admin'))
        )
    );
END;
$$;

-- 管理者追加用の関数（super_adminのみ実行可能）
CREATE OR REPLACE FUNCTION add_admin_user(
    new_email text,
    new_role text DEFAULT 'admin'
)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    current_user_email text;
BEGIN
    -- 現在のユーザーのメールアドレスを取得
    SELECT email INTO current_user_email 
    FROM auth.users 
    WHERE id = auth.uid();
    
    -- super_admin権限チェック
    IF NOT is_admin(current_user_email, 'super_admin') THEN
        RETURN 'エラー: super_admin権限が必要です';
    END IF;
    
    -- 管理者を追加
    INSERT INTO admin_users (email, role, granted_by, is_active)
    VALUES (new_email, new_role, auth.uid(), true)
    ON CONFLICT (email) DO UPDATE SET 
        role = EXCLUDED.role,
        granted_by = EXCLUDED.granted_by,
        is_active = true;
    
    RETURN '管理者を追加しました: ' || new_email || ' (role: ' || new_role || ')';
END;
$$;

-- 管理者削除用の関数（super_adminのみ実行可能）
CREATE OR REPLACE FUNCTION remove_admin_user(target_email text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    current_user_email text;
BEGIN
    -- 現在のユーザーのメールアドレスを取得
    SELECT email INTO current_user_email 
    FROM auth.users 
    WHERE id = auth.uid();
    
    -- super_admin権限チェック
    IF NOT is_admin(current_user_email, 'super_admin') THEN
        RETURN 'エラー: super_admin権限が必要です';
    END IF;
    
    -- 自分自身を削除しようとしていないかチェック
    IF current_user_email = target_email THEN
        RETURN 'エラー: 自分自身の管理者権限は削除できません';
    END IF;
    
    -- 管理者を非アクティブ化
    UPDATE admin_users 
    SET is_active = false 
    WHERE email = target_email;
    
    RETURN '管理者を削除しました: ' || target_email;
END;
$$;

-- 8. 管理者管理用のクエリ例

-- 現在の管理者一覧を表示
-- SELECT * FROM admin_users WHERE is_active = true ORDER BY role, granted_at;

-- 管理者を追加（super_adminのみ実行可能）
-- SELECT add_admin_user('newadmin@example.com', 'admin');

-- 管理者を削除（super_adminのみ実行可能）
-- SELECT remove_admin_user('oldadmin@example.com');

-- 現在のユーザーの管理者権限を確認
-- SELECT is_admin((SELECT email FROM auth.users WHERE id = auth.uid()), 'admin');

-- 9. 確認クエリ
SELECT * FROM storage.buckets WHERE name = 'character-images';
SELECT policyname, cmd, qual FROM pg_policies 
WHERE schemaname = 'storage' AND tablename = 'objects';
SELECT * FROM admin_users WHERE is_active = true;